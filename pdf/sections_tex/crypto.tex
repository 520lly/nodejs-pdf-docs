\section{Crypto}\label{crypto}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Stability: }\DecValTok{2} \NormalTok{- Unstable; API changes are being discussed }\KeywordTok{for}
\NormalTok{future }\OtherTok{versions}\NormalTok{.  }\FunctionTok{Breaking} \FunctionTok{changes} \FunctionTok{will} \FunctionTok{be} \OtherTok{minimized}\NormalTok{.  }\FunctionTok{See} \OtherTok{below}\NormalTok{.}
\end{Highlighting}
\end{Shaded}

Use \texttt{require(\textquotesingle{}crypto\textquotesingle{})} to
access this module.

The crypto module offers a way of encapsulating secure credentials to be
used as part of a secure HTTPS net or http connection.

It also offers a set of wrappers for OpenSSL's hash, hmac, cipher,
decipher, sign and verify methods.

\subsection{crypto.setEngine(engine{[},
flags{]})}\label{crypto.setengineengine-flags}

Load and set engine for some/all OpenSSL functions (selected by flags).

\texttt{engine} could be either an id or a path to the to the engine's
shared library.

\texttt{flags} is optional and has \texttt{ENGINE\_METHOD\_ALL} value by
default. It could take one of or mix of following flags (defined in
\texttt{constants} module):

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{ENGINE\_METHOD\_RSA}
\item
  \texttt{ENGINE\_METHOD\_DSA}
\item
  \texttt{ENGINE\_METHOD\_DH}
\item
  \texttt{ENGINE\_METHOD\_RAND}
\item
  \texttt{ENGINE\_METHOD\_ECDH}
\item
  \texttt{ENGINE\_METHOD\_ECDSA}
\item
  \texttt{ENGINE\_METHOD\_CIPHERS}
\item
  \texttt{ENGINE\_METHOD\_DIGESTS}
\item
  \texttt{ENGINE\_METHOD\_STORE}
\item
  \texttt{ENGINE\_METHOD\_PKEY\_METH}
\item
  \texttt{ENGINE\_METHOD\_PKEY\_ASN1\_METH}
\item
  \texttt{ENGINE\_METHOD\_ALL}
\item
  \texttt{ENGINE\_METHOD\_NONE}
\end{itemize}

\subsection{crypto.getCiphers()}\label{crypto.getciphers}

Returns an array with the names of the supported ciphers.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var} \NormalTok{ciphers = }\OtherTok{crypto}\NormalTok{.}\FunctionTok{getCiphers}\NormalTok{();}
\OtherTok{console}\NormalTok{.}\FunctionTok{log}\NormalTok{(ciphers); }\CommentTok{// ['AES-128-CBC', 'AES-128-CBC-HMAC-SHA1', ...]}
\end{Highlighting}
\end{Shaded}

\subsection{crypto.getHashes()}\label{crypto.gethashes}

Returns an array with the names of the supported hash algorithms.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var} \NormalTok{hashes = }\OtherTok{crypto}\NormalTok{.}\FunctionTok{getHashes}\NormalTok{();}
\OtherTok{console}\NormalTok{.}\FunctionTok{log}\NormalTok{(hashes); }\CommentTok{// ['sha', 'sha1', 'sha1WithRSAEncryption', ...]}
\end{Highlighting}
\end{Shaded}

\subsection{crypto.createCredentials(details)}\label{crypto.createcredentialsdetails}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Stability: }\DecValTok{0} \NormalTok{- }\OtherTok{Deprecated}\NormalTok{. }\FunctionTok{Use} \NormalTok{[}\OtherTok{tls}\NormalTok{.}\FunctionTok{createSecureContext}\NormalTok{][] }\OtherTok{instead}\NormalTok{.}
\end{Highlighting}
\end{Shaded}

Creates a credentials object, with the optional details being a
dictionary with keys:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{pfx} : A string or buffer holding the PFX or PKCS12 encoded
  private key, certificate and CA certificates
\item
  \texttt{key} : A string holding the PEM encoded private key
\item
  \texttt{passphrase} : A string of passphrase for the private key or
  pfx
\item
  \texttt{cert} : A string holding the PEM encoded certificate
\item
  \texttt{ca} : Either a string or list of strings of PEM encoded CA
  certificates to trust.
\item
  \texttt{crl} : Either a string or list of strings of PEM encoded CRLs
  (Certificate Revocation List)
\item
  \texttt{ciphers}: A string describing the ciphers to use or exclude.
  Consult
  \url{http://www.openssl.org/docs/apps/ciphers.html\#CIPHER_LIST_FORMAT}
  for details on the format.
\end{itemize}

If no `ca' details are given, then node.js will use the default publicly
trusted list of CAs as given in
\url{http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt}.

\subsection{crypto.createHash(algorithm)}\label{crypto.createhashalgorithm}

Creates and returns a hash object, a cryptographic hash with the given
algorithm which can be used to generate hash digests.

\texttt{algorithm} is dependent on the available algorithms supported by
the version of OpenSSL on the platform. Examples are
\texttt{\textquotesingle{}sha1\textquotesingle{}},
\texttt{\textquotesingle{}md5\textquotesingle{}},
\texttt{\textquotesingle{}sha256\textquotesingle{}},
\texttt{\textquotesingle{}sha512\textquotesingle{}}, etc. On recent
releases, \texttt{openssl\ list-message-digest-algorithms} will display
the available digest algorithms.

Example: this program that takes the sha1 sum of a file

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var} \NormalTok{filename = }\OtherTok{process}\NormalTok{.}\FunctionTok{argv}\NormalTok{[}\DecValTok{2}\NormalTok{];}
\KeywordTok{var} \NormalTok{crypto = }\FunctionTok{require}\NormalTok{(}\StringTok{'crypto'}\NormalTok{);}
\KeywordTok{var} \NormalTok{fs = }\FunctionTok{require}\NormalTok{(}\StringTok{'fs'}\NormalTok{);}

\KeywordTok{var} \NormalTok{shasum = }\OtherTok{crypto}\NormalTok{.}\FunctionTok{createHash}\NormalTok{(}\StringTok{'sha1'}\NormalTok{);}

\KeywordTok{var} \NormalTok{s = }\OtherTok{fs}\NormalTok{.}\FunctionTok{ReadStream}\NormalTok{(filename);}
\OtherTok{s}\NormalTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{'data'}\NormalTok{, }\KeywordTok{function}\NormalTok{(d) \{}
  \OtherTok{shasum}\NormalTok{.}\FunctionTok{update}\NormalTok{(d);}
\NormalTok{\});}

\OtherTok{s}\NormalTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{'end'}\NormalTok{, }\KeywordTok{function}\NormalTok{() \{}
  \KeywordTok{var} \NormalTok{d = }\OtherTok{shasum}\NormalTok{.}\FunctionTok{digest}\NormalTok{(}\StringTok{'hex'}\NormalTok{);}
  \OtherTok{console}\NormalTok{.}\FunctionTok{log}\NormalTok{(d + }\StringTok{'  '} \NormalTok{+ filename);}
\NormalTok{\});}
\end{Highlighting}
\end{Shaded}

\subsection{Class: Hash}\label{class-hash}

The class for creating hash digests of data.

It is a \href{stream.html}{stream} that is both readable and writable.
The written data is used to compute the hash. Once the writable side of
the stream is ended, use the \texttt{read()} method to get the computed
hash digest. The legacy \texttt{update} and \texttt{digest} methods are
also supported.

Returned by \texttt{crypto.createHash}.

\subsubsection{hash.update(data{[},
input\_encoding{]})}\label{hash.updatedata-inputux5fencoding}

Updates the hash content with the given \texttt{data}, the encoding of
which is given in \texttt{input\_encoding} and can be
\texttt{\textquotesingle{}utf8\textquotesingle{}},
\texttt{\textquotesingle{}ascii\textquotesingle{}} or
\texttt{\textquotesingle{}binary\textquotesingle{}}. If no encoding is
provided and the input is a string an encoding of
\texttt{\textquotesingle{}binary\textquotesingle{}} is enforced. If
\texttt{data} is a \texttt{Buffer} then \texttt{input\_encoding} is
ignored.

This can be called many times with new data as it is streamed.

\subsubsection{hash.digest({[}encoding{]})}\label{hash.digestencoding}

Calculates the digest of all of the passed data to be hashed. The
\texttt{encoding} can be
\texttt{\textquotesingle{}hex\textquotesingle{}},
\texttt{\textquotesingle{}binary\textquotesingle{}} or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

Note: \texttt{hash} object can not be used after \texttt{digest()}
method has been called.

\subsection{crypto.createHmac(algorithm,
key)}\label{crypto.createhmacalgorithm-key}

Creates and returns a hmac object, a cryptographic hmac with the given
algorithm and key.

It is a \href{stream.html}{stream} that is both readable and writable.
The written data is used to compute the hmac. Once the writable side of
the stream is ended, use the \texttt{read()} method to get the computed
digest. The legacy \texttt{update} and \texttt{digest} methods are also
supported.

\texttt{algorithm} is dependent on the available algorithms supported by
OpenSSL - see createHash above. \texttt{key} is the hmac key to be used.

\subsection{Class: Hmac}\label{class-hmac}

Class for creating cryptographic hmac content.

Returned by \texttt{crypto.createHmac}.

\subsubsection{hmac.update(data)}\label{hmac.updatedata}

Update the hmac content with the given \texttt{data}. This can be called
many times with new data as it is streamed.

\subsubsection{hmac.digest({[}encoding{]})}\label{hmac.digestencoding}

Calculates the digest of all of the passed data to the hmac. The
\texttt{encoding} can be
\texttt{\textquotesingle{}hex\textquotesingle{}},
\texttt{\textquotesingle{}binary\textquotesingle{}} or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

Note: \texttt{hmac} object can not be used after \texttt{digest()}
method has been called.

\subsection{crypto.createCipher(algorithm,
password)}\label{crypto.createcipheralgorithm-password}

Creates and returns a cipher object, with the given algorithm and
password.

\texttt{algorithm} is dependent on OpenSSL, examples are
\texttt{\textquotesingle{}aes192\textquotesingle{}}, etc. On recent
releases, \texttt{openssl\ list-cipher-algorithms} will display the
available cipher algorithms. \texttt{password} is used to derive key and
IV, which must be a \texttt{\textquotesingle{}binary\textquotesingle{}}
encoded string or a \href{buffer.html}{buffer}.

It is a \href{stream.html}{stream} that is both readable and writable.
The written data is used to compute the hash. Once the writable side of
the stream is ended, use the \texttt{read()} method to get the
enciphered contents. The legacy \texttt{update} and \texttt{final}
methods are also supported.

Note: \texttt{createCipher} derives keys with the OpenSSL function
\href{https://www.openssl.org/docs/crypto/EVP_BytesToKey.html}{EVP\_BytesToKey}
with the digest algorithm set to MD5, one iteration, and no salt. The
lack of salt allows dictionary attacks as the same password always
creates the same key. The low iteration count and non-cryptographically
secure hash algorithm allow passwords to be tested very rapidly.

In line with OpenSSL's recommendation to use pbkdf2 instead of
EVP\_BytesToKey it is recommended you derive a key and iv yourself with
\hyperref[cryptoux5fcryptoux5fpbkdf2ux5fpasswordux5fsaltux5fiterationsux5fkeylenux5fcallback]{crypto.pbkdf2}
and to then use
\hyperref[cryptoux5fcryptoux5fcreatecipherivux5falgorithmux5fkeyux5fiv]{createCipheriv()}
to create the cipher stream.

\subsection{crypto.createCipheriv(algorithm, key,
iv)}\label{crypto.createcipherivalgorithm-key-iv}

Creates and returns a cipher object, with the given algorithm, key and
iv.

\texttt{algorithm} is the same as the argument to
\texttt{createCipher()}. \texttt{key} is the raw key used by the
algorithm. \texttt{iv} is an
\href{http://en.wikipedia.org/wiki/Initialization_vector}{initialization
vector}.

\texttt{key} and \texttt{iv} must be
\texttt{\textquotesingle{}binary\textquotesingle{}} encoded strings or
\href{buffer.html}{buffers}.

\subsection{Class: Cipher}\label{class-cipher}

Class for encrypting data.

Returned by \texttt{crypto.createCipher} and
\texttt{crypto.createCipheriv}.

Cipher objects are \href{stream.html}{streams} that are both readable
and writable. The written plain text data is used to produce the
encrypted data on the readable side. The legacy \texttt{update} and
\texttt{final} methods are also supported.

\subsubsection{cipher.update(data{[}, input\_encoding{]}{[},
output\_encoding{]})}\label{cipher.updatedata-inputux5fencoding-outputux5fencoding}

Updates the cipher with \texttt{data}, the encoding of which is given in
\texttt{input\_encoding} and can be
\texttt{\textquotesingle{}utf8\textquotesingle{}},
\texttt{\textquotesingle{}ascii\textquotesingle{}} or
\texttt{\textquotesingle{}binary\textquotesingle{}}. If no encoding is
provided, then a buffer is expected. If \texttt{data} is a
\texttt{Buffer} then \texttt{input\_encoding} is ignored.

The \texttt{output\_encoding} specifies the output format of the
enciphered data, and can be
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}base64\textquotesingle{}} or
\texttt{\textquotesingle{}hex\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

Returns the enciphered contents, and can be called many times with new
data as it is streamed.

\subsubsection{cipher.final({[}output\_encoding{]})}\label{cipher.finaloutputux5fencoding}

Returns any remaining enciphered contents, with
\texttt{output\_encoding} being one of:
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}base64\textquotesingle{}} or
\texttt{\textquotesingle{}hex\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

Note: \texttt{cipher} object can not be used after \texttt{final()}
method has been called.

\subsubsection{cipher.setAutoPadding(auto\_padding=true)}\label{cipher.setautopaddingautoux5fpaddingtrue}

You can disable automatic padding of the input data to block size. If
\texttt{auto\_padding} is false, the length of the entire input data
must be a multiple of the cipher's block size or \texttt{final} will
fail. Useful for non-standard padding, e.g.~using \texttt{0x0} instead
of PKCS padding. You must call this before \texttt{cipher.final}.

\subsubsection{cipher.getAuthTag()}\label{cipher.getauthtag}

For authenticated encryption modes (currently supported: GCM), this
method returns a \texttt{Buffer} that represents the
\emph{authentication tag} that has been computed from the given data.
Should be called after encryption has been completed using the
\texttt{final} method!

\subsubsection{cipher.setAAD(buffer)}\label{cipher.setaadbuffer}

For authenticated encryption modes (currently supported: GCM), this
method sets the value used for the additional authenticated data (AAD)
input parameter.

\subsection{crypto.createDecipher(algorithm,
password)}\label{crypto.createdecipheralgorithm-password}

Creates and returns a decipher object, with the given algorithm and key.
This is the mirror of the
\hyperref[cryptoux5fcryptoux5fcreatecipherux5falgorithmux5fpassword]{createCipher()}
above.

\subsection{crypto.createDecipheriv(algorithm, key,
iv)}\label{crypto.createdecipherivalgorithm-key-iv}

Creates and returns a decipher object, with the given algorithm, key and
iv. This is the mirror of the
\hyperref[cryptoux5fcryptoux5fcreatecipherivux5falgorithmux5fkeyux5fiv]{createCipheriv()}
above.

\subsection{Class: Decipher}\label{class-decipher}

Class for decrypting data.

Returned by \texttt{crypto.createDecipher} and
\texttt{crypto.createDecipheriv}.

Decipher objects are \href{stream.html}{streams} that are both readable
and writable. The written enciphered data is used to produce the
plain-text data on the the readable side. The legacy \texttt{update} and
\texttt{final} methods are also supported.

\subsubsection{decipher.update(data{[}, input\_encoding{]}{[},
output\_encoding{]})}\label{decipher.updatedata-inputux5fencoding-outputux5fencoding}

Updates the decipher with \texttt{data}, which is encoded in
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}base64\textquotesingle{}} or
\texttt{\textquotesingle{}hex\textquotesingle{}}. If no encoding is
provided, then a buffer is expected. If \texttt{data} is a
\texttt{Buffer} then \texttt{input\_encoding} is ignored.

The \texttt{output\_decoding} specifies in what format to return the
deciphered plaintext:
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}ascii\textquotesingle{}} or
\texttt{\textquotesingle{}utf8\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

\subsubsection{decipher.final({[}output\_encoding{]})}\label{decipher.finaloutputux5fencoding}

Returns any remaining plaintext which is deciphered, with
\texttt{output\_encoding} being one of:
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}ascii\textquotesingle{}} or
\texttt{\textquotesingle{}utf8\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

Note: \texttt{decipher} object can not be used after \texttt{final()}
method has been called.

\subsubsection{decipher.setAutoPadding(auto\_padding=true)}\label{decipher.setautopaddingautoux5fpaddingtrue}

You can disable auto padding if the data has been encrypted without
standard block padding to prevent \texttt{decipher.final} from checking
and removing it. Can only work if the input data's length is a multiple
of the ciphers block size. You must call this before streaming data to
\texttt{decipher.update}.

\subsubsection{decipher.setAuthTag(buffer)}\label{decipher.setauthtagbuffer}

For authenticated encryption modes (currently supported: GCM), this
method must be used to pass in the received \emph{authentication tag}.
If no tag is provided or if the ciphertext has been tampered with,
\texttt{final} will throw, thus indicating that the ciphertext should be
discarded due to failed authentication.

\subsubsection{decipher.setAAD(buffer)}\label{decipher.setaadbuffer}

For authenticated encryption modes (currently supported: GCM), this
method sets the value used for the additional authenticated data (AAD)
input parameter.

\subsection{crypto.createSign(algorithm)}\label{crypto.createsignalgorithm}

Creates and returns a signing object, with the given algorithm. On
recent OpenSSL releases, \texttt{openssl\ list-public-key-algorithms}
will display the available signing algorithms. Examples are
\texttt{\textquotesingle{}RSA-SHA256\textquotesingle{}}.

\subsection{Class: Sign}\label{class-sign}

Class for generating signatures.

Returned by \texttt{crypto.createSign}.

Sign objects are writable \href{stream.html}{streams}. The written data
is used to generate the signature. Once all of the data has been
written, the \texttt{sign} method will return the signature. The legacy
\texttt{update} method is also supported.

\subsubsection{sign.update(data)}\label{sign.updatedata}

Updates the sign object with data. This can be called many times with
new data as it is streamed.

\subsubsection{sign.sign(private\_key{[},
output\_format{]})}\label{sign.signprivateux5fkey-outputux5fformat}

Calculates the signature on all the updated data passed through the
sign.

\texttt{private\_key} can be an object or a string. If
\texttt{private\_key} is a string, it is treated as the key with no
passphrase.

\texttt{private\_key}:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{key} : A string holding the PEM encoded private key
\item
  \texttt{passphrase} : A string of passphrase for the private key
\end{itemize}

Returns the signature in \texttt{output\_format} which can be
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}} or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

Note: \texttt{sign} object can not be used after \texttt{sign()} method
has been called.

\subsection{crypto.createVerify(algorithm)}\label{crypto.createverifyalgorithm}

Creates and returns a verification object, with the given algorithm.
This is the mirror of the signing object above.

\subsection{Class: Verify}\label{class-verify}

Class for verifying signatures.

Returned by \texttt{crypto.createVerify}.

Verify objects are writable \href{stream.html}{streams}. The written
data is used to validate against the supplied signature. Once all of the
data has been written, the \texttt{verify} method will return true if
the supplied signature is valid. The legacy \texttt{update} method is
also supported.

\subsubsection{verifier.update(data)}\label{verifier.updatedata}

Updates the verifier object with data. This can be called many times
with new data as it is streamed.

\subsubsection{verifier.verify(object, signature{[},
signature\_format{]})}\label{verifier.verifyobject-signature-signatureux5fformat}

Verifies the signed data by using the \texttt{object} and
\texttt{signature}. \texttt{object} is a string containing a PEM encoded
object, which can be one of RSA public key, DSA public key, or X.509
certificate. \texttt{signature} is the previously calculated signature
for the data, in the \texttt{signature\_format} which can be
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}} or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
specified, then a buffer is expected.

Returns true or false depending on the validity of the signature for the
data and public key.

Note: \texttt{verifier} object can not be used after \texttt{verify()}
method has been called.

\subsection{crypto.createDiffieHellman(prime\_length{[},
generator{]})}\label{crypto.creatediffiehellmanprimeux5flength-generator}

Creates a Diffie-Hellman key exchange object and generates a prime of
\texttt{prime\_length} bits and using an optional specific numeric
\texttt{generator}. If no \texttt{generator} is specified, then
\texttt{2} is used.

\subsection{crypto.createDiffieHellman(prime{[}, prime\_encoding{]}{[},
generator{]}{[},
generator\_encoding{]})}\label{crypto.creatediffiehellmanprime-primeux5fencoding-generator-generatorux5fencoding}

Creates a Diffie-Hellman key exchange object using the supplied
\texttt{prime} and an optional specific \texttt{generator}.
\texttt{generator} can be a number, string, or Buffer. If no
\texttt{generator} is specified, then \texttt{2} is used.
\texttt{prime\_encoding} and \texttt{generator\_encoding} can be
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}}, or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no
\texttt{prime\_encoding} is specified, then a Buffer is expected for
\texttt{prime}. If no \texttt{generator\_encoding} is specified, then a
Buffer is expected for \texttt{generator}.

\subsection{Class: DiffieHellman}\label{class-diffiehellman}

The class for creating Diffie-Hellman key exchanges.

Returned by \texttt{crypto.createDiffieHellman}.

\subsubsection{diffieHellman.verifyError}\label{diffiehellman.verifyerror}

A bit field containing any warnings and/or errors as a result of a check
performed during initialization. The following values are valid for this
property (defined in \texttt{constants} module):

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{DH\_CHECK\_P\_NOT\_SAFE\_PRIME}
\item
  \texttt{DH\_CHECK\_P\_NOT\_PRIME}
\item
  \texttt{DH\_UNABLE\_TO\_CHECK\_GENERATOR}
\item
  \texttt{DH\_NOT\_SUITABLE\_GENERATOR}
\end{itemize}

\subsubsection{diffieHellman.generateKeys({[}encoding{]})}\label{diffiehellman.generatekeysencoding}

Generates private and public Diffie-Hellman key values, and returns the
public key in the specified encoding. This key should be transferred to
the other party. Encoding can be
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}}, or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

\subsubsection{diffieHellman.computeSecret(other\_public\_key{[},
input\_encoding{]}{[},
output\_encoding{]})}\label{diffiehellman.computesecretotherux5fpublicux5fkey-inputux5fencoding-outputux5fencoding}

Computes the shared secret using \texttt{other\_public\_key} as the
other party's public key and returns the computed shared secret.
Supplied key is interpreted using specified \texttt{input\_encoding},
and secret is encoded using specified \texttt{output\_encoding}.
Encodings can be \texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}}, or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If the input
encoding is not provided, then a buffer is expected.

If no output encoding is given, then a buffer is returned.

\subsubsection{diffieHellman.getPrime({[}encoding{]})}\label{diffiehellman.getprimeencoding}

Returns the Diffie-Hellman prime in the specified encoding, which can be
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}}, or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

\subsubsection{diffieHellman.getGenerator({[}encoding{]})}\label{diffiehellman.getgeneratorencoding}

Returns the Diffie-Hellman generator in the specified encoding, which
can be \texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}}, or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

\subsubsection{diffieHellman.getPublicKey({[}encoding{]})}\label{diffiehellman.getpublickeyencoding}

Returns the Diffie-Hellman public key in the specified encoding, which
can be \texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}}, or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

\subsubsection{diffieHellman.getPrivateKey({[}encoding{]})}\label{diffiehellman.getprivatekeyencoding}

Returns the Diffie-Hellman private key in the specified encoding, which
can be \texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}}, or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

\subsubsection{diffieHellman.setPublicKey(public\_key{[},
encoding{]})}\label{diffiehellman.setpublickeypublicux5fkey-encoding}

Sets the Diffie-Hellman public key. Key encoding can be
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}} or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is expected.

\subsubsection{diffieHellman.setPrivateKey(private\_key{[},
encoding{]})}\label{diffiehellman.setprivatekeyprivateux5fkey-encoding}

Sets the Diffie-Hellman private key. Key encoding can be
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}} or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is expected.

\subsection{crypto.getDiffieHellman(group\_name)}\label{crypto.getdiffiehellmangroupux5fname}

Creates a predefined Diffie-Hellman key exchange object. The supported
groups are: \texttt{\textquotesingle{}modp1\textquotesingle{}},
\texttt{\textquotesingle{}modp2\textquotesingle{}},
\texttt{\textquotesingle{}modp5\textquotesingle{}} (defined in
\href{http://www.rfc-editor.org/rfc/rfc2412.txt}{RFC 2412}) and
\texttt{\textquotesingle{}modp14\textquotesingle{}},
\texttt{\textquotesingle{}modp15\textquotesingle{}},
\texttt{\textquotesingle{}modp16\textquotesingle{}},
\texttt{\textquotesingle{}modp17\textquotesingle{}},
\texttt{\textquotesingle{}modp18\textquotesingle{}} (defined in
\href{http://www.rfc-editor.org/rfc/rfc3526.txt}{RFC 3526}). The
returned object mimics the interface of objects created by
\hyperref[cryptoux5fcryptoux5fcreatediffiehellmanux5fprimeux5fencoding]{crypto.createDiffieHellman()}
above, but will not allow to change the keys (with
\hyperref[cryptoux5fdiffiehellmanux5fsetpublickeyux5fpublicux5fkeyux5fencoding]{diffieHellman.setPublicKey()}
for example). The advantage of using this routine is that the parties
don't have to generate nor exchange group modulus beforehand, saving
both processor and communication time.

Example (obtaining a shared secret):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var} \NormalTok{crypto = }\FunctionTok{require}\NormalTok{(}\StringTok{'crypto'}\NormalTok{);}
\KeywordTok{var} \NormalTok{alice = }\OtherTok{crypto}\NormalTok{.}\FunctionTok{getDiffieHellman}\NormalTok{(}\StringTok{'modp5'}\NormalTok{);}
\KeywordTok{var} \NormalTok{bob = }\OtherTok{crypto}\NormalTok{.}\FunctionTok{getDiffieHellman}\NormalTok{(}\StringTok{'modp5'}\NormalTok{);}

\OtherTok{alice}\NormalTok{.}\FunctionTok{generateKeys}\NormalTok{();}
\OtherTok{bob}\NormalTok{.}\FunctionTok{generateKeys}\NormalTok{();}

\KeywordTok{var} \NormalTok{alice_secret = }\OtherTok{alice}\NormalTok{.}\FunctionTok{computeSecret}\NormalTok{(}\OtherTok{bob}\NormalTok{.}\FunctionTok{getPublicKey}\NormalTok{(), }\KeywordTok{null}\NormalTok{, }\StringTok{'hex'}\NormalTok{);}
\KeywordTok{var} \NormalTok{bob_secret = }\OtherTok{bob}\NormalTok{.}\FunctionTok{computeSecret}\NormalTok{(}\OtherTok{alice}\NormalTok{.}\FunctionTok{getPublicKey}\NormalTok{(), }\KeywordTok{null}\NormalTok{, }\StringTok{'hex'}\NormalTok{);}

\CommentTok{/* alice_secret and bob_secret should be the same */}
\OtherTok{console}\NormalTok{.}\FunctionTok{log}\NormalTok{(alice_secret == bob_secret);}
\end{Highlighting}
\end{Shaded}

\subsection{crypto.createECDH(curve\_name)}\label{crypto.createecdhcurveux5fname}

Creates a Elliptic Curve (EC) Diffie-Hellman key exchange object using a
predefined curve specified by \texttt{curve\_name} string.

\subsection{Class: ECDH}\label{class-ecdh}

The class for creating EC Diffie-Hellman key exchanges.

Returned by \texttt{crypto.createECDH}.

\subsubsection{ECDH.generateKeys({[}encoding{[},
format{]}{]})}\label{ecdh.generatekeysencoding-format}

Generates private and public EC Diffie-Hellman key values, and returns
the public key in the specified format and encoding. This key should be
transferred to the other party.

Format specifies point encoding and can be
\texttt{\textquotesingle{}compressed\textquotesingle{}},
\texttt{\textquotesingle{}uncompressed\textquotesingle{}}, or
\texttt{\textquotesingle{}hybrid\textquotesingle{}}. If no format is
provided - the point will be returned in
\texttt{\textquotesingle{}uncompressed\textquotesingle{}} format.

Encoding can be \texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}}, or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

\subsubsection{ECDH.computeSecret(other\_public\_key{[},
input\_encoding{]}{[},
output\_encoding{]})}\label{ecdh.computesecretotherux5fpublicux5fkey-inputux5fencoding-outputux5fencoding}

Computes the shared secret using \texttt{other\_public\_key} as the
other party's public key and returns the computed shared secret.
Supplied key is interpreted using specified \texttt{input\_encoding},
and secret is encoded using specified \texttt{output\_encoding}.
Encodings can be \texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}}, or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If the input
encoding is not provided, then a buffer is expected.

If no output encoding is given, then a buffer is returned.

\subsubsection{ECDH.getPublicKey({[}encoding{[},
format{]}{]})}\label{ecdh.getpublickeyencoding-format}

Returns the EC Diffie-Hellman public key in the specified encoding and
format.

Format specifies point encoding and can be
\texttt{\textquotesingle{}compressed\textquotesingle{}},
\texttt{\textquotesingle{}uncompressed\textquotesingle{}}, or
\texttt{\textquotesingle{}hybrid\textquotesingle{}}. If no format is
provided - the point will be returned in
\texttt{\textquotesingle{}uncompressed\textquotesingle{}} format.

Encoding can be \texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}}, or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

\subsubsection{ECDH.getPrivateKey({[}encoding{]})}\label{ecdh.getprivatekeyencoding}

Returns the EC Diffie-Hellman private key in the specified encoding,
which can be \texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}}, or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is returned.

\subsubsection{ECDH.setPublicKey(public\_key{[},
encoding{]})}\label{ecdh.setpublickeypublicux5fkey-encoding}

Sets the EC Diffie-Hellman public key. Key encoding can be
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}} or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is expected.

\subsubsection{ECDH.setPrivateKey(private\_key{[},
encoding{]})}\label{ecdh.setprivatekeyprivateux5fkey-encoding}

Sets the EC Diffie-Hellman private key. Key encoding can be
\texttt{\textquotesingle{}binary\textquotesingle{}},
\texttt{\textquotesingle{}hex\textquotesingle{}} or
\texttt{\textquotesingle{}base64\textquotesingle{}}. If no encoding is
provided, then a buffer is expected.

Example (obtaining a shared secret):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var} \NormalTok{crypto = }\FunctionTok{require}\NormalTok{(}\StringTok{'crypto'}\NormalTok{);}
\KeywordTok{var} \NormalTok{alice = }\OtherTok{crypto}\NormalTok{.}\FunctionTok{createECDH}\NormalTok{(}\StringTok{'secp256k1'}\NormalTok{);}
\KeywordTok{var} \NormalTok{bob = }\OtherTok{crypto}\NormalTok{.}\FunctionTok{createECDH}\NormalTok{(}\StringTok{'secp256k1'}\NormalTok{);}

\OtherTok{alice}\NormalTok{.}\FunctionTok{generateKeys}\NormalTok{();}
\OtherTok{bob}\NormalTok{.}\FunctionTok{generateKeys}\NormalTok{();}

\KeywordTok{var} \NormalTok{alice_secret = }\OtherTok{alice}\NormalTok{.}\FunctionTok{computeSecret}\NormalTok{(}\OtherTok{bob}\NormalTok{.}\FunctionTok{getPublicKey}\NormalTok{(), }\KeywordTok{null}\NormalTok{, }\StringTok{'hex'}\NormalTok{);}
\KeywordTok{var} \NormalTok{bob_secret = }\OtherTok{bob}\NormalTok{.}\FunctionTok{computeSecret}\NormalTok{(}\OtherTok{alice}\NormalTok{.}\FunctionTok{getPublicKey}\NormalTok{(), }\KeywordTok{null}\NormalTok{, }\StringTok{'hex'}\NormalTok{);}

\CommentTok{/* alice_secret and bob_secret should be the same */}
\OtherTok{console}\NormalTok{.}\FunctionTok{log}\NormalTok{(alice_secret == bob_secret);}
\end{Highlighting}
\end{Shaded}

\subsection{crypto.pbkdf2(password, salt, iterations, keylen{[},
digest{]},
callback)}\label{crypto.pbkdf2password-salt-iterations-keylen-digest-callback}

Asynchronous PBKDF2 function. Applies the selected HMAC digest function
(default: SHA1) to derive a key of the requested length from the
password, salt and number of iterations. The callback gets two
arguments: \texttt{(err,\ derivedKey)}.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{crypto}\NormalTok{.}\FunctionTok{pbkdf2}\NormalTok{(}\StringTok{'secret'}\NormalTok{, }\StringTok{'salt'}\NormalTok{, }\DecValTok{4096}\NormalTok{, }\DecValTok{512}\NormalTok{, }\StringTok{'sha256'}\NormalTok{, }\KeywordTok{function}\NormalTok{(err, key) \{}
  \KeywordTok{if} \NormalTok{(err)}
    \KeywordTok{throw} \NormalTok{err;}
  \OtherTok{console}\NormalTok{.}\FunctionTok{log}\NormalTok{(}\OtherTok{key}\NormalTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{'hex'}\NormalTok{));  }\CommentTok{// 'c5e478d...1469e50'}
\NormalTok{\});}
\end{Highlighting}
\end{Shaded}

You can get a list of supported digest functions with
\hyperref[cryptoux5fcryptoux5fgethashes]{crypto.getHashes()}.

\subsection{crypto.pbkdf2Sync(password, salt, iterations, keylen{[},
digest{]})}\label{crypto.pbkdf2syncpassword-salt-iterations-keylen-digest}

Synchronous PBKDF2 function. Returns derivedKey or throws error.

\subsection{crypto.randomBytes(size{[},
callback{]})}\label{crypto.randombytessize-callback}

Generates cryptographically strong pseudo-random data. Usage:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// async}
\OtherTok{crypto}\NormalTok{.}\FunctionTok{randomBytes}\NormalTok{(}\DecValTok{256}\NormalTok{, }\KeywordTok{function}\NormalTok{(ex, buf) \{}
  \KeywordTok{if} \NormalTok{(ex) }\KeywordTok{throw} \NormalTok{ex;}
  \OtherTok{console}\NormalTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{'Have %d bytes of random data: %s'}\NormalTok{, }\OtherTok{buf}\NormalTok{.}\FunctionTok{length}\NormalTok{, buf);}
\NormalTok{\});}

\CommentTok{// sync}
\KeywordTok{try} \NormalTok{\{}
  \KeywordTok{var} \NormalTok{buf = }\OtherTok{crypto}\NormalTok{.}\FunctionTok{randomBytes}\NormalTok{(}\DecValTok{256}\NormalTok{);}
  \OtherTok{console}\NormalTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{'Have %d bytes of random data: %s'}\NormalTok{, }\OtherTok{buf}\NormalTok{.}\FunctionTok{length}\NormalTok{, buf);}
\NormalTok{\} }\KeywordTok{catch} \NormalTok{(ex) \{}
  \CommentTok{// handle error}
  \CommentTok{// most likely, entropy sources are drained}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

NOTE: Will throw error or invoke callback with error, if there is not
enough accumulated entropy to generate cryptographically strong data. In
other words, \texttt{crypto.randomBytes} without callback will not block
even if all entropy sources are drained.

\subsection{crypto.pseudoRandomBytes(size{[},
callback{]})}\label{crypto.pseudorandombytessize-callback}

Generates \emph{non}-cryptographically strong pseudo-random data. The
data returned will be unique if it is sufficiently long, but is not
necessarily unpredictable. For this reason, the output of this function
should never be used where unpredictability is important, such as in the
generation of encryption keys.

Usage is otherwise identical to \texttt{crypto.randomBytes}.

\subsection{Class: Certificate}\label{class-certificate}

The class used for working with signed public key \& challenges. The
most common usage for this series of functions is when dealing with the
\texttt{\textless{}keygen\textgreater{}} element.
http://www.openssl.org/docs/apps/spkac.html

Returned by \texttt{crypto.Certificate}.

\subsubsection{Certificate.verifySpkac(spkac)}\label{certificate.verifyspkacspkac}

Returns true of false based on the validity of the SPKAC.

\subsubsection{Certificate.exportChallenge(spkac)}\label{certificate.exportchallengespkac}

Exports the encoded public key from the supplied SPKAC.

\subsubsection{Certificate.exportPublicKey(spkac)}\label{certificate.exportpublickeyspkac}

Exports the encoded challenge associated with the SPKAC.

\subsection{crypto.publicEncrypt(public\_key,
buffer)}\label{crypto.publicencryptpublicux5fkey-buffer}

Encrypts \texttt{buffer} with \texttt{public\_key}. Only RSA is
currently supported.

\texttt{public\_key} can be an object or a string. If
\texttt{public\_key} is a string, it is treated as the key with no
passphrase and will use \texttt{RSA\_PKCS1\_OAEP\_PADDING}.

\texttt{public\_key}:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{key} : A string holding the PEM encoded private key
\item
  \texttt{padding} : An optional padding value, one of the following:
\item
  \texttt{constants.RSA\_NO\_PADDING}
\item
  \texttt{constants.RSA\_PKCS1\_PADDING}
\item
  \texttt{constants.RSA\_PKCS1\_OAEP\_PADDING}
\end{itemize}

NOTE: All paddings are defined in \texttt{constants} module.

\subsection{crypto.privateDecrypt(private\_key,
buffer)}\label{crypto.privatedecryptprivateux5fkey-buffer}

Decrypts \texttt{buffer} with \texttt{private\_key}.

\texttt{private\_key} can be an object or a string. If
\texttt{private\_key} is a string, it is treated as the key with no
passphrase and will use \texttt{RSA\_PKCS1\_OAEP\_PADDING}.

\texttt{private\_key}:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{key} : A string holding the PEM encoded private key
\item
  \texttt{passphrase} : An optional string of passphrase for the private
  key
\item
  \texttt{padding} : An optional padding value, one of the following:
\item
  \texttt{constants.RSA\_NO\_PADDING}
\item
  \texttt{constants.RSA\_PKCS1\_PADDING}
\item
  \texttt{constants.RSA\_PKCS1\_OAEP\_PADDING}
\end{itemize}

NOTE: All paddings are defined in \texttt{constants} module.

\subsection{crypto.DEFAULT\_ENCODING}\label{crypto.defaultux5fencoding}

The default encoding to use for functions that can take either strings
or buffers. The default value is
\texttt{\textquotesingle{}buffer\textquotesingle{}}, which makes it
default to using Buffer objects. This is here to make the crypto module
more easily compatible with legacy programs that expected
\texttt{\textquotesingle{}binary\textquotesingle{}} to be the default
encoding.

Note that new programs will probably expect buffers, so only use this as
a temporary measure.

\subsection{Recent API Changes}\label{recent-api-changes}

The Crypto module was added to Node before there was the concept of a
unified Stream API, and before there were Buffer objects for handling
binary data.

As such, the streaming classes don't have the typical methods found on
other Node classes, and many methods accepted and returned
Binary-encoded strings by default rather than Buffers. This was changed
to use Buffers by default instead.

This is a breaking change for some use cases, but not all.

For example, if you currently use the default arguments to the Sign
class, and then pass the results to the Verify class, without ever
inspecting the data, then it will continue to work as before. Where you
once got a binary string and then presented the binary string to the
Verify object, you'll now get a Buffer, and present the Buffer to the
Verify object.

However, if you were doing things with the string data that will not
work properly on Buffers (such as, concatenating them, storing in
databases, etc.), or you are passing binary strings to the crypto
functions without an encoding argument, then you will need to start
providing encoding arguments to specify which encoding you'd like to
use. To switch to the previous style of using binary strings by default,
set the \texttt{crypto.DEFAULT\_ENCODING} field to `binary'. Note that
new programs will probably expect buffers, so only use this as a
temporary measure.
